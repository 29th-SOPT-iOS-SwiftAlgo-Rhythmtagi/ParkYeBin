# 다이나믹 프로그래밍(Dynamic Programming).  
 : 메모리 공간을 약간 더 사용해 연산 속도를 비약적으로 증가시킬 수 있는 방법   
### 다이나믹 프로그래밍의 조건
1) 큰 문제를 작은 문제로 나눌 수 있다.   
2) 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.   
### 다이나믹 프로그래밍 구현 방법 2가지
1) 탑다운 방식(TopDown, 하향식 방식)
  : 재귀함수를 이용해 재귀적으로 다이나믹 프로그래밍 구현   
    큰 문제를 해결하기 위해 작은 문제를 해결하므로 TopDown
 * 메모이제이션(Memoization, 캐싱) : 한 번 구한 결과는 리스트에 저장해두고 같은 정보가 필요할 때 리스트에서 값을 가져오는 방식   
2) 보텀업 방식(BottomUp, 상향식 방식)   
  : 반복문을 이용해 작은 문제부터 답을 도출하므로 BottomUp   
 * DP 테이블 : 앞서 계산된 결과를 저장하기 위한 테이블   
  
### 다이나믹 프로그래밍 Tip
 - 일반적으로 재귀함수보다는 반복문을 사용한 다이나믹 프로그래밍 성능이 좋다. (함수 호출에 필요한 과정 수행 여부 때문)     
 - 대체로 코딩 테스트에서 간단한 형태로 출제된다.   
 - 특정 문제를 완전 탐색 알고리즘으로 접근 시 시간이 오래걸리는 경우 다이나믹 프로그래밍을 생각해보자.
 - 재귀함수를 적용한 뒤 메모이제이션으로 소스코드를 수정하는 것도 좋은 방법이다.
### 피보나치 수열 예제
```1, 1, 2, 3, 4, 8, 13, 21, 34, 55, 80 ...```
* n번째 피보나치 수 = (n-1)번째 피보나치 수 + (n-2)번째 피보나치 수
* 단, 1번째 피보나치 수 = 1, 2번째 피보나치 수 = 1

1. **일반적인 재귀함수 사용**
```swift
func fibo(x: Int) -> Int {
    if x == 1 || x == 2 {
        return 1
    }
    return fibo(x: x - 1) + fibo(x: x - 2)
}
```
* 문제점 : 재귀함수가 중복되어 호출되기 때문에 x가 커질 수록 시간 복잡도가 높아진다.
<img src="https://user-images.githubusercontent.com/46108770/137095312-a7f5b8b1-cfb9-4800-ba79-48a7624f6a81.png" width="400" height="300"/>

2. 탑다운 방식 사용
 : 메모이제이션을 사용해 리스트에 한 번 구한 값을 저장하고 꺼내오는 방식으로 구현
```swift
// 한 번 계산된 결과를 메모이제이션하기 위한 리스트 초기화
var d = [Int](repeating: 0, count: 100)
 
func fibo(x: Int) -> Int {
    // 종료 조건
    if x == 1 || x == 2 {
        return 1
    }
    // 이미 구한 값이라면 해당 값을 사용
    if d[x] != 0 {
        return d[x]
    }
    return fibo(x: x - 1) + fibo(x: x - 2)
}
```
<img src="https://user-images.githubusercontent.com/46108770/137098485-73314784-709f-4227-854e-e802d13d0445.png" width="400" height="300"/>

3. 보텀업 방식 사용
 : DP 테이블을 이용
```swift
// 한 번 계산된 결과를 메모이제이션하기 위한 리스트 초기화
var d = [Int](repeating: 0, count: 100)

d[1] = 1
d[2] = 2

for i in 3...99 {
    d[i] = d[i - 1] + d[i - 2]
    print(d[i])
}
```



